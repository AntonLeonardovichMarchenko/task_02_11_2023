import math

# суперкласс. В случае необходимости сюда можно накрутить много чего.
# У суперкласса self от подкласса? Своего self нет?
class Point0D:

    def __init__(self, name, args):
        self.name = name
        objDescriptor = name + ' :'
        for arg in args:
            objDescriptor += str(arg) + ' '

        self.objDescriptor = objDescriptor


class Point3D(Point0D):
    # вызывается непосредственно перед созданием объекта.
    # в практике программирования встречаются самые разнообразные задачи и
    # иногда нужно что-то делать и до создания объектов.
    # метод __new__, у которого первым идет обязательный параметр cls – это ссылка
    # на текущий класс Point3D, затем - список из фактических и формальных параметров,
    # которые может принимать данная функция. Это стандартное определение метода __new__
    # в классах. В теле метода сделан вывод сообщения и переменной cls.
    def __new__(cls, *args):
        print(f'вызов __new__ для {str(cls)}')
        return super().__new__(cls)

    # вызывается ПОСЛЕ создания объекта:
    def __init__(self, x, y, z):
        # в инициализатор суперкласса уходит имя подкласса и кортеж значений
        xyz = (x,y,z,)
        Point0D.__init__(self, 'Point3D', xyz)   # Обращение к базовому классу.
                                                 # Аргументы: имя и кортеж значений

        # из суперкласса self.name (имя класса) и self.objDescriptor (строка с описанием
        # объекта): имя класса и значения координат. ТОЛЬКО значения.
        # Суперкласс ничего не знает об именах осей координат. Хотя можно было бы в него
        # вместо кортежа значений засунуть словарь. Правда, это не упростило бы весь
        # процесс разработки класса.

        # print(self.objDescriptor)
        # print(self.name)

        self.x = x
        self.y = y
        self.z = z

    # Вернуть ответ, являются ли точки равными.
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y and self.z == other.z

    # Вернуть ответ, являются ли точки разными.
    # С использованием ранее реализованной операции == .
    def __ne__(self, other):
        return not (self == other)

    # сложение точек. Запускается бинарным оператором +
    def __add__(self, other):
        # Создать новый объект как сумму координат self и other. Параметры:
        #             - other (Point3D): вернуть новый объект-сумму;
        #             - other (int, float): сдвинуть точку на other по x, y и z;
        #             - other (другой тип): возбудить исключение TypeError.

        if isinstance(other, self.__class__):
            # Точка с точкой
            # Возвращается новый объект!
            return Point3D(self.x + other.x, self.y + other.y, self.z + other.z)
        elif isinstance(other, (int, float)):
            # Точка и число (сдвиг)
            # Добавить ко всем координатам self число other и вернуть результат.
            # Возвращается старый, измененный, объект!
            self.x += other
            self.y += other
            self.z += other
            return self
        else:
            # В противном случае возбуждается исключение
            raise TypeError(f" impossible add {self.__class__} + {type(other)}")

    # вычитание точек. Запускается бинарным оператором -
    def __sub__(self, other):
        # Создать новый объект как разность координат self и other.
        return Point3D(self.x - other.x, self.y - other.y, self.z - other.z)

    # инверсия точки
    def __neg__(self):
        # Вернуть новый объект, инвертировав координаты.
        return Point3D(-self.x, -self.y, -self.z)

    # строковое представление точки. Запускается при строковом преобразовании.
    # в частности функцией str() или при неявном преобразовании в функции print(...)
    def __str__(self):
        return (f'{self.name}: x {self.x}, y {self.y}, z {self.z}')

    # определение значения атрибута (координаты) по словарю.
    # При неправильном item возвращается None
    def __dict__(self, item):
        xyz = {'x': self.x, 'y': self.y, 'z': self.z}
        return xyz.get(item)


    # магический метод __getitem__ запускается оператором value = obj[key].
    # Назначение: поиск атрибута по его ключу и возвращение его значения
    def __getitem__(self, item):
        return self.__dict__(item)

    # магический метод __setitem__ запускается оператором obj[key] = value.
    # Назначение: ВЫБОР атрибута по его ключу и изменение его значения
    def __setitem__(self, key, value):
        if key == 'x':
            self.x = value
        elif key == 'y':
            self.y = value
        elif key == 'z':
            self.z = value

    # статическому методу на вход подаётся СПИСОК объектов Point3D
    # Оператор assert работает как логическое выражение, проверяя,
    # является ли заданное условие истинным или ложным. Если условие истинно,
    # то ничего не происходит и выполняется следующая строка кода.
    # Если же условие ложно, оператор assert останавливает выполнение программы и
    # выдает ошибку. В этом случае assert работает как ключевое слово raise и выводит
    # исключение. Исключение, вызванное оператором assert, также называется AssertionError
    @staticmethod
    def summ(*points3D):

        assert len(points3D) > 0, 'Количество суммируемых точек равно 0'
        res = points3D[0]
        for point in points3D[1:]:
            res += point    # эта операция в особом определении НЕ нуждается!
                            # В основе она уже была определена методом __add__

        return res


    # расстояние между точкой и началом координат
    @staticmethod
    def r0(point3D):
        r0 = math.sqrt(point3D.x*point3D.x + point3D.y*point3D.y + point3D.z*point3D.z)
        return r0

    # расстояние между точками
    @staticmethod
    def rPoints(*points3D):

        rPoints = math.sqrt(points3D[1].x - points3D[0].x**2 +
                            points3D[1].у - points3D[0].у**2 +
                            points3D[1].z - points3D[0].z**2)
        return rPoints

    # Много вещей можно сделать с объектом и для объекта, минуя стандартные магические
    # методы и не "заморачиваясь" жёстким синтаксисом, специально "предназначенным"
    # для решения соответсвующих задач программирования со всеми их правилами
    # вызова и применения.
    # Конечно же, они не сокращают количество проблемм, связанных с "традиционным"
    # кодированием, но вносят определённое разнообразие в процесс разработки.

    # Метод класса — это метод, который привязан к классу, а не к объекту класса.
    # Для этого в python применяются методы класса @classmethod со стандартным аргументом cls.
    # При этом существует РАЗНИЦА между статическим методом (функцией класса) и методом класса:
    # = Статический метод ничего не знает о классе и имеет дело только с параметрами.
    # = Метод класса работает с классом, поскольку его параметром всегда является сам класс.
    #   Метод класса может вызываться как классом, так и его объектом.
    #   Class.classmethod() Or object.classmethod(). Но несмотря ни на что,
    #   метод класса всегда присоединяется к классу с первым аргументом.
    #   cls — стандартное имя первого аргумента методов класса.
    #   В ходе исполнения метода класса в первом аргументе автоматически
    #   окажется класс. Дальше - аргументы метода класса (здесь - для Point3D).

    # Это метод класса. cls внутри метода класса: имя класса можно узнать
    # НЕ только от объекта, а и от cls - ссылки на класс метода класса.
    # Имя класса присваивается в этой реализации присваивается объекту,
    # а прочитывается в методе класса
    @classmethod
    def print_class_name(cls):
        print("Class name:", cls.__name__)

    # и создать объект можно с помощью метода класса, минуя магический метод __init__ .
    # Не статической функцией и не методом объекта, а именно МЕТОДОМ (у него тоже
    # обязательный параметр) класса!
    @classmethod
    def create(cls, x, y, z):
        print('create')
        return cls(x, y, z)

    # альтернативный метод класса. Делает то же самое: создаёт объекты...
    # Часто методы класса так же просто создавать как и методы объекта
    @classmethod
    def go_create(cls, x, y, z):
        print('go_create')
        return cls(x, y, z)

    # Создать объект класса из строки 'str_value'. Этот метод класса
    # доступен для вызова как: Point3D.from_string(...)
    # Параметры:
    #    - cls: ссылка на класс (Point3D);
    #    - str_value: строка вида "float, float, float".
    # Результат:
    #    - Объект класса Point3D.
    @classmethod
    def fromString(cls, str_value):

        values = [float(x) for x in str_value.split(',')]   # список значений координат из строки
        assert len(values) == 3   # проверка количества значений в списке координат
        # пример использования свойства cls — создание фабричного метода класса.
        # Фабричные методы позволяют создавать объекты определенного класса НЕ обращаясь
        # при этом к помощи конструктора.
        return cls(*values)

    # вывод информации об объекте в формате, пригодном для дальнейшего
    # применения методом Point3D.fromString(...)
    @classmethod
    def toString(cls, p):
        pStr = f'{p.x}, {p.y}, {p.z}'
        return pStr

def pTst():
    p0 = Point3D(3, 0, 3)
    print(p0)
    p0Str = Point3D.toString(p0)
    print(p0Str)
    p1 = Point3D(3, 3, 3)
    print(p1)
    p_fromStr = Point3D.fromString(Point3D.toString(p1))
    print(f'.....{p_fromStr}.....')

    if p0 == p1:
        print(f'p0 {p0} == p1 {p1}')
    else:
        print(f'p0 {p0} != p1 {p1}')

    p3 = Point3D.create(1, 2, 3)
    p4 = Point3D.go_create(5, 6, 36)

    print(f'{p3 + p4}')


    p5 = Point3D.fromString('77, 88, 99')
    print(p5)

    # магический метод __getitem__ в действии:
    # у объекта obj поиск значения атрибута по его имени.
    # Возвращение значения в случае успеха или None в случае неудачи

    val = p5['x']
    print(val)

    val = p5['y']
    print(val)

    val = p5['z']
    print(val)

    val = p5['QWERTY']
    print(val)

    # магический метод __setitem__ в действии:
    # у объекта obj поиск атрибута по его имени.
    # Изменение значения значения атрибута в случае успеха.
    # В случае неудачи - НИЧЕГО не происходит
    p5['x'] = 525
    print(f'==={p5}===')

    strPoint = str(p5)
    print(strPoint)

#  Это условие блокирует вызов функции тестирующей функции pTst()
#  при импорте модуля pointMaster из других модулей.
if __name__=='__main__':
    pTst()


